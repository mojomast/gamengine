<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slopvania - A Metroidvania Adventure</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e);
            font-family: 'Courier New', monospace;
            color: #ffffff;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #gameContainer {
            border: 2px solid #ff206e;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(255, 32, 110, 0.3);
            position: relative;
        }

        #gameCanvas {
            display: block;
            background: linear-gradient(135deg, #001122, #112233);
            width: 100%;
            max-width: 1200px;
            height: 600px;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            pointer-events: none;
        }

        .health-bar {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00f593;
            border-radius: 20px;
            padding: 5px;
            margin-bottom: 10px;
            width: 200px;
        }

        .health-fill {
            height: 20px;
            background: linear-gradient(90deg, #ff206e, #00f593);
            border-radius: 15px;
            transition: width 0.3s ease;
        }

        .abilities {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .ability {
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #666;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .ability.unlocked {
            border-color: #00f593;
            box-shadow: 0 0 10px rgba(0, 245, 147, 0.5);
        }

        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.4;
        }

        #minimap {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 200px;
            height: 120px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff206e;
            border-radius: 8px;
            padding: 5px;
        }

        #minimap canvas {
            width: 100%;
            height: 100%;
            border-radius: 4px;
        }

        #gameInfo {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.4;
            text-align: right;
        }

        #saveControls {
            position: absolute;
            top: 50%;
            left: 10px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            display: none;
        }

        .save-button {
            background: #ff206e;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .save-button:hover {
            background: #ff4081;
        }

        .completion-bar {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ffd700;
            border-radius: 20px;
            padding: 3px;
            margin-top: 5px;
            width: 200px;
        }

        .completion-fill {
            height: 12px;
            background: linear-gradient(90deg, #ffd700, #ff6b9d);
            border-radius: 15px;
            transition: width 0.5s ease;
            position: relative;
        }

        .completion-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: bold;
            color: #000;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #ff206e;
            text-shadow: 0 0 10px rgba(255, 32, 110, 0.5);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="600"></canvas>
        
        <!-- Game UI Overlay -->
        <div id="ui">
            <div class="health-bar">
                <div class="health-fill" id="healthFill" style="width: 100%"></div>
            </div>
            <div class="abilities">
                <div class="ability" id="jumpAbility" title="Jump">ðŸ¦˜</div>
                <div class="ability" id="dashAbility" title="Dash">ðŸ’¨</div>
                <div class="ability" id="wallJumpAbility" title="Wall Jump">ðŸ§—</div>
                <div class="ability" id="doubleJumpAbility" title="Double Jump">ðŸ¦‹</div>
            </div>
            <div class="completion-bar">
                <div class="completion-fill" id="completionFill" style="width: 25%">
                    <div class="completion-text" id="completionText">25%</div>
                </div>
            </div>
        </div>

        <!-- Mini-map -->
        <div id="minimap">
            <canvas id="minimapCanvas" width="190" height="110"></canvas>
        </div>

        <!-- Game Info -->
        <div id="gameInfo">
            <div id="areaName">Starting Area</div>
            <div id="itemCount">Items: 0/3</div>
            <div id="playTime">Time: 00:00</div>
        </div>

        <!-- Save Controls -->
        <div id="saveControls">
            <button class="save-button" id="saveBtn">Save Game</button><br>
            <button class="save-button" id="loadBtn">Load Game</button><br>
            <button class="save-button" id="exportBtn">Export</button><br>
            <button class="save-button" id="importBtn">Import</button>
        </div>

        <div id="controls">
            <strong>Controls:</strong><br>
            Arrow Keys / WASD - Move<br>
            Space - Jump<br>
            Shift - Dash (when unlocked)<br>
            E - Interact<br>
            M - Mini-map<br>
            F5 - Quick Save<br>
            F9 - Save Menu
        </div>

        <div class="loading" id="loading">Loading Slopvania...</div>
    </div>

    <!-- Game Engine Scripts -->
    <script type="module" src="./save-system.js"></script>
    <script type="module">
        import { GameEngine } from '../game-engine/src/core/GameEngine.js';
        import { Scene } from '../game-engine/src/core/Scene.js';
        import { GameObject } from '../game-engine/src/core/GameObject.js';
        import { SlopvaniaSaveSystem } from './save-system.js';
        
        // Game constants
        const WORLD_WIDTH = 4800;  // 4 screens wide
        const WORLD_HEIGHT = 2400; // 4 screens tall
        const TILE_SIZE = 32;
        
        // Player physics constants
        const GRAVITY = 1800;  // Much stronger gravity for faster falling
        const JUMP_FORCE = -2000; // SUPER high jumps - can reach any platform!
        const MOVE_SPEED = 200;
        const DASH_SPEED = 600;
        const DASH_DURATION = 0.2;

        // Initialize save system
        const saveSystem = new SlopvaniaSaveSystem();
        let startTime = Date.now();
        let lastAutoSave = Date.now();
        
        // Game state
        let gameState = {
            player: null,
            camera: { x: 0, y: 0, targetX: 0, targetY: 0 },
            abilities: {
                jump: true,
                dash: false,
                wallJump: false,
                doubleJump: false
            },
            health: 100,
            maxHealth: 100,
            currentArea: 'start',
            visitedAreas: new Set(['start']),
            collectedItems: new Set(),
            playTime: 0,
            deaths: 0,
            showHints: true,
            musicVolume: 1.0,
            sfxVolume: 1.0
        };

        // SVG Graphics as data URIs
        const sprites = {
            player: `data:image/svg+xml;base64,${btoa(`
                <svg width="32" height="32" xmlns="http://www.w3.org/2000/svg">
                    <rect x="8" y="4" width="16" height="20" fill="#ff206e" rx="2"/>
                    <rect x="6" y="8" width="4" height="12" fill="#ff206e"/>
                    <rect x="22" y="8" width="4" height="12" fill="#ff206e"/>
                    <rect x="10" y="24" width="4" height="8" fill="#ff206e"/>
                    <rect x="18" y="24" width="4" height="8" fill="#ff206e"/>
                    <circle cx="13" cy="12" r="2" fill="#00f593"/>
                    <circle cx="19" cy="12" r="2" fill="#00f593"/>
                </svg>
            `)}`,
            
            wall: `data:image/svg+xml;base64,${btoa(`
                <svg width="32" height="32" xmlns="http://www.w3.org/2000/svg">
                    <rect x="0" y="0" width="32" height="32" fill="#2a2a4a"/>
                    <rect x="2" y="2" width="28" height="28" fill="#3a3a5a" stroke="#555" stroke-width="1"/>
                    <rect x="4" y="4" width="24" height="24" fill="#444466"/>
                </svg>
            `)}`,
            
            ground: `data:image/svg+xml;base64,${btoa(`
                <svg width="32" height="32" xmlns="http://www.w3.org/2000/svg">
                    <rect x="0" y="0" width="32" height="32" fill="#1a4a2a"/>
                    <rect x="0" y="0" width="32" height="4" fill="#2a6a3a"/>
                    <circle cx="8" cy="16" r="2" fill="#2a5a2a"/>
                    <circle cx="24" cy="20" r="1" fill="#2a5a2a"/>
                </svg>
            `)}`,
            
            dashItem: `data:image/svg+xml;base64,${btoa(`
                <svg width="32" height="32" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="16" cy="16" r="12" fill="#ffd700" stroke="#ffaa00" stroke-width="2"/>
                    <path d="M8 16 L24 16 M20 12 L24 16 L20 20" stroke="#ffffff" stroke-width="2" fill="none"/>
                </svg>
            `)}`,
            
            wallJumpItem: `data:image/svg+xml;base64,${btoa(`
                <svg width="32" height="32" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="16" cy="16" r="12" fill="#00f593" stroke="#00aa73" stroke-width="2"/>
                    <rect x="6" y="8" width="4" height="16" fill="#ffffff"/>
                    <path d="M14 12 L22 16 L14 20" fill="#ffffff"/>
                </svg>
            `)}`,
            
            doubleJumpItem: `data:image/svg+xml;base64,${btoa(`
                <svg width="32" height="32" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="16" cy="16" r="12" fill="#ff6b9d" stroke="#ff4081" stroke-width="2"/>
                    <path d="M12 20 Q16 8 20 20" stroke="#ffffff" stroke-width="2" fill="none"/>
                    <path d="M10 16 Q16 6 22 16" stroke="#ffffff" stroke-width="2" fill="none"/>
                </svg>
            `)}`
        };

        // Player class
        class Player extends GameObject {
            constructor(x, y) {
                super(x, y);
                this.size = { width: 32, height: 32 };
                this.physics.enabled = true;
                this.physics.gravity = GRAVITY;
                this.collision.enabled = true;
                this.collision.size = { width: 24, height: 30 };
                
                this.grounded = false;
                this.jumpCount = 0;
                this.dashCooldown = 0;
                this.dashTime = 0;
                this.wallSliding = false;
                this.wallJumpCooldown = 0;
                
                this.sprite = new Image();
                this.sprite.onload = () => {}; // Sprite loaded
                this.sprite.onerror = () => {}; // Use fallback rendering
                this.sprite.src = sprites.player;
                
                this.addTag('player');
            }

            update(deltaTime) {
                const input = this.scene.engine.inputManager;
                
                // Reset grounded state
                this.grounded = false;
                this.wallSliding = false;
                
                // Debug logging removed for cleaner console
                
                // Update cooldowns
                this.dashCooldown = Math.max(0, this.dashCooldown - deltaTime);
                this.wallJumpCooldown = Math.max(0, this.wallJumpCooldown - deltaTime);
                this.dashTime = Math.max(0, this.dashTime - deltaTime);
                
                // Horizontal movement
                if (this.dashTime <= 0) {
                    if (input.isKeyDown('ArrowLeft') || input.isKeyDown('KeyA')) {
                        this.velocity.x = -MOVE_SPEED;
                    } else if (input.isKeyDown('ArrowRight') || input.isKeyDown('KeyD')) {
                        this.velocity.x = MOVE_SPEED;
                    } else {
                        this.velocity.x *= 0.8; // Friction
                    }
                }
                
                // Test all possible jump inputs - try both isKeyPressed and isKeyDown
                const spacePressed = (input.isKeyPressed && input.isKeyPressed('Space')) || (input.isKeyDown && input.isKeyDown('Space'));
                const upPressed = (input.isKeyPressed && input.isKeyPressed('ArrowUp')) || (input.isKeyDown && input.isKeyDown('ArrowUp'));
                const wPressed = (input.isKeyPressed && input.isKeyPressed('KeyW')) || (input.isKeyDown && input.isKeyDown('KeyW'));
                
                // Jumping - fix input detection
                if ((spacePressed || upPressed || wPressed) && this.wallJumpCooldown <= 0) {
                    if (this.grounded && gameState.abilities.jump) {
                        this.velocity.y = JUMP_FORCE;
                        this.jumpCount = 1;
                    } else if (this.jumpCount < 2 && gameState.abilities.doubleJump) {
                        this.velocity.y = JUMP_FORCE * 0.8;
                        this.jumpCount++;
                    } else if (this.wallSliding && gameState.abilities.wallJump) {
                        this.velocity.y = JUMP_FORCE * 0.9;
                        this.velocity.x = this.velocity.x > 0 ? -MOVE_SPEED * 1.5 : MOVE_SPEED * 1.5;
                        this.wallJumpCooldown = 0.3;
                    }
                }
                
                // Dashing
                if (input.isKeyPressed('ShiftLeft') && gameState.abilities.dash && this.dashCooldown <= 0) {
                    const direction = input.isKeyDown('ArrowLeft') || input.isKeyDown('KeyA') ? -1 : 
                                     input.isKeyDown('ArrowRight') || input.isKeyDown('KeyD') ? 1 : 
                                     this.velocity.x > 0 ? 1 : -1;
                    
                    this.velocity.x = direction * DASH_SPEED;
                    this.velocity.y = 0;
                    this.dashTime = DASH_DURATION;
                    this.dashCooldown = 1.0;
                }
                
                // Call parent update
                super.update(deltaTime);
                
                // Ground/wall collision detection
                this.checkCollisions();
                
                // Update camera to follow player
                this.updateCamera();
                
                // Keep player in world bounds
                this.position.x = Math.max(16, Math.min(WORLD_WIDTH - 16, this.position.x));
                this.position.y = Math.max(16, Math.min(WORLD_HEIGHT - 16, this.position.y));
            }
            
            checkCollisions() {
                const world = this.scene.world;
                const tileX = Math.floor(this.position.x / TILE_SIZE);
                const tileY = Math.floor(this.position.y / TILE_SIZE);
                
                // Store previous grounded state to avoid spam
                const wasGrounded = this.grounded;
                
                // Check surrounding tiles
                for (let x = tileX - 1; x <= tileX + 1; x++) {
                    for (let y = tileY - 1; y <= tileY + 1; y++) {
                        if (world.getTile(x, y) === 1) { // Solid tile
                            const tileRect = {
                                x: x * TILE_SIZE,
                                y: y * TILE_SIZE,
                                width: TILE_SIZE,
                                height: TILE_SIZE
                            };
                            
                            const playerRect = {
                                x: this.position.x - 12,
                                y: this.position.y - 15,
                                width: 24,
                                height: 30
                            };
                            
                            if (this.rectsOverlap(playerRect, tileRect)) {
                                this.resolveCollision(playerRect, tileRect, wasGrounded);
                            }
                        }
                    }
                }
            }
            
            rectsOverlap(a, b) {
                return a.x < b.x + b.width &&
                       a.x + a.width > b.x &&
                       a.y < b.y + b.height &&
                       a.y + a.height > b.y;
            }
            
            resolveCollision(player, tile, wasGrounded = false) {
                const overlapX = Math.min(player.x + player.width - tile.x, tile.x + tile.width - player.x);
                const overlapY = Math.min(player.y + player.height - tile.y, tile.y + tile.height - player.y);
                
                if (overlapX < overlapY) {
                    // Horizontal collision
                    if (player.x < tile.x) {
                        this.position.x = tile.x - 12;
                        if (this.velocity.x > 0) this.velocity.x = 0;
                        this.wallSliding = gameState.abilities.wallJump && this.velocity.y > 0;
                    } else {
                        this.position.x = tile.x + tile.width + 12;
                        if (this.velocity.x < 0) this.velocity.x = 0;
                        this.wallSliding = gameState.abilities.wallJump && this.velocity.y > 0;
                    }
                } else {
                    // Vertical collision
                    if (player.y < tile.y) {
                        // Landing on top of tile
                        this.position.y = tile.y - 15;
                        if (this.velocity.y > 0) {
                            this.velocity.y = 0;
                            this.grounded = true;
                            this.jumpCount = 0;
                            // Player landed
                        }
                    } else {
                        // Hitting tile from below
                        this.position.y = tile.y + tile.width + 15;
                        if (this.velocity.y < 0) this.velocity.y = 0;
                    }
                }
            }
            
            updateCamera() {
                gameState.camera.targetX = this.position.x - 600;
                gameState.camera.targetY = this.position.y - 300;
                
                // Smooth camera following
                gameState.camera.x += (gameState.camera.targetX - gameState.camera.x) * 0.1;
                gameState.camera.y += (gameState.camera.targetY - gameState.camera.y) * 0.1;
                
                // Keep camera in bounds
                gameState.camera.x = Math.max(0, Math.min(WORLD_WIDTH - 1200, gameState.camera.x));
                gameState.camera.y = Math.max(0, Math.min(WORLD_HEIGHT - 600, gameState.camera.y));
                
                this.scene.camera.x = gameState.camera.x;
                this.scene.camera.y = gameState.camera.y;
            }

            draw(ctx) {
                // If SVG sprite is loaded, use it; otherwise draw programmatically
                if (this.sprite && this.sprite.complete && this.sprite.naturalWidth > 0) {
                    ctx.drawImage(this.sprite, 0, 0, this.size.width, this.size.height);
                } else {
                    // Draw SVG-style character programmatically
                    this.drawSVGStyle(ctx);
                }
                
                // Draw dash effect
                if (this.dashTime > 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.6;
                    ctx.fillStyle = '#ffd700';
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#ffd700';
                    ctx.fillRect(-4, -2, this.size.width + 8, this.size.height + 4);
                    ctx.restore();
                }
            }
            
            drawSVGStyle(ctx) {
                ctx.save();
                
                // Main body (rounded rectangle)
                ctx.fillStyle = '#ff206e';
                this.roundRect(ctx, 8, 4, 16, 20, 2);
                
                // Arms
                ctx.fillRect(6, 8, 4, 12); // Left arm
                ctx.fillRect(22, 8, 4, 12); // Right arm
                
                // Legs
                ctx.fillRect(10, 24, 4, 8); // Left leg
                ctx.fillRect(18, 24, 4, 8); // Right leg
                
                // Eyes (glowing green circles)
                ctx.fillStyle = '#00f593';
                ctx.beginPath();
                ctx.arc(13, 12, 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(19, 12, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Add subtle glow to eyes
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.shadowBlur = 3;
                ctx.shadowColor = '#00f593';
                ctx.beginPath();
                ctx.arc(13, 12, 1, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(19, 12, 1, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                
                ctx.restore();
            }
            
            // Helper function for rounded rectangles
            roundRect(ctx, x, y, width, height, radius) {
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
                ctx.fill();
            }
        }

        // World/Map class
        class World {
            constructor() {
                this.width = WORLD_WIDTH / TILE_SIZE;
                this.height = WORLD_HEIGHT / TILE_SIZE;
                this.tiles = new Array(this.width * this.height).fill(0);
                this.items = [];
                
                this.generateWorld();
            }
            
            generateWorld() {
                // Create a comprehensive Metroidvania-style world with full connectivity
                
                // Ground layer
                for (let x = 0; x < this.width; x++) {
                    for (let y = this.height - 5; y < this.height; y++) {
                        this.setTile(x, y, 1);
                    }
                }
                
                // Create ceiling for enclosed feeling
                for (let x = 0; x < this.width; x++) {
                    this.setTile(x, 0, 1);
                    this.setTile(x, 1, 1);
                }
                
                // Create side walls
                for (let y = 0; y < this.height; y++) {
                    this.setTile(0, y, 1);
                    this.setTile(1, y, 1);
                    this.setTile(this.width - 1, y, 1);
                    this.setTile(this.width - 2, y, 1);
                }
                
                // Create platforms and walls for different areas
                this.createStartArea();
                this.createConnectingPlatforms();
                this.createDashArea();
                this.createMidLevelPlatforms();
                this.createWallJumpArea();
                this.createHighLevelPlatforms();
                this.createDoubleJumpArea();
                this.createVerticalShafts();
                
                // Place upgrade items
                this.placeItems();
            }
            
            createStartArea() {
                // Starting platform and tutorial area (left side)
                for (let x = 5; x < 30; x++) {
                    this.setTile(x, this.height - 15, 1);
                }
                
                // Stepped platforms for easy climbing - much lower
                for (let x = 8; x < 15; x++) {
                    this.setTile(x, this.height - 10, 1);  // Much lower
                }
                for (let x = 10; x < 17; x++) {
                    this.setTile(x, this.height - 12, 1);  // Much lower
                }
                for (let x = 12; x < 19; x++) {
                    this.setTile(x, this.height - 15, 1);  // Much lower
                }
                
                // Medium platform accessible with basic jump
                for (let x = 22; x < 28; x++) {
                    this.setTile(x, this.height - 12, 1);  // Much lower
                }
                
                // Connection to next area
                for (let x = 28; x < 32; x++) {
                    this.setTile(x, this.height - 10, 1);  // Much lower
                }
            }
            
            createConnectingPlatforms() {
                // Platforms that connect different areas
                
                // Low-level connectors
                for (let x = 30; x < 40; x++) {
                    if (x % 6 < 3) { // Create gaps
                        this.setTile(x, this.height - 8, 1);   // Much lower
                    }
                }
                
                // Mid-level bridge
                for (let x = 32; x < 45; x++) {
                    this.setTile(x, this.height - 15, 1);   // Much lower
                }
                
                // Upper connecting platforms
                for (let x = 35; x < 42; x++) {
                    this.setTile(x, this.height - 20, 1);   // Much lower
                }
                for (let x = 47; x < 54; x++) {
                    this.setTile(x, this.height - 25, 1);   // Much lower
                }
            }
            
            createDashArea() {
                // Area requiring dash ability (middle-left)
                const startX = 45;
                
                // Entry platform
                for (let x = startX - 5; x < startX + 3; x++) {
                    this.setTile(x, this.height - 18, 1);
                }
                
                // Platforms with gaps that require dashing
                for (let x = startX; x < startX + 6; x++) {
                    this.setTile(x, this.height - 25, 1);
                }
                
                // Large gap here - needs dash to cross (8 tiles wide)
                for (let x = startX + 14; x < startX + 20; x++) {
                    this.setTile(x, this.height - 25, 1);
                }
                
                // Platform with dash item
                for (let x = startX + 16; x < startX + 22; x++) {
                    this.setTile(x, this.height - 30, 1);
                }
                
                // Vertical climbing platforms
                for (let i = 0; i < 4; i++) {
                    for (let x = startX + 12 + i * 2; x < startX + 15 + i * 2; x++) {
                        this.setTile(x, this.height - 35 + i * 3, 1);
                    }
                }
                
                // Upper platforms
                for (let x = startX + 8; x < startX + 25; x++) {
                    if (x % 8 < 5) { // Intermittent platforms
                        this.setTile(x, this.height - 40, 1);
                    }
                }
            }
            
            createMidLevelPlatforms() {
                // Connecting platforms at mid-height
                for (let x = 55; x < 75; x++) {
                    if (x % 10 < 6) { // Intermittent platforms
                        this.setTile(x, this.height - 28, 1);
                    }
                }
                
                // Stepping stones
                for (let i = 0; i < 8; i++) {
                    this.setTile(65 + i * 3, this.height - 32 + i, 1);
                    this.setTile(66 + i * 3, this.height - 32 + i, 1);
                }
            }
            
            createWallJumpArea() {
                // Area requiring wall jump (middle-right)
                const startX = 75;
                
                // Entry platforms
                for (let x = startX - 8; x < startX - 2; x++) {
                    this.setTile(x, this.height - 20, 1);
                }
                
                // Tall vertical walls for wall jumping
                for (let y = this.height - 45; y < this.height - 8; y++) {
                    this.setTile(startX, y, 1);
                    this.setTile(startX + 8, y, 1);
                    this.setTile(startX + 16, y, 1);
                    this.setTile(startX + 24, y, 1);
                }
                
                // Small platforms between walls for resting
                for (let x = startX + 2; x < startX + 6; x++) {
                    this.setTile(x, this.height - 30, 1);
                }
                for (let x = startX + 10; x < startX + 14; x++) {
                    this.setTile(x, this.height - 38, 1);
                }
                for (let x = startX + 18; x < startX + 22; x++) {
                    this.setTile(x, this.height - 42, 1);
                }
                
                // Wall jump item platform
                for (let x = startX + 19; x < startX + 25; x++) {
                    this.setTile(x, this.height - 48, 1);
                }
            }
            
            createHighLevelPlatforms() {
                // Upper level connectors
                for (let x = 85; x < 105; x++) {
                    if (x % 12 < 8) { // Long platforms with gaps
                        this.setTile(x, this.height - 45, 1);
                    }
                }
                
                // Sky bridges
                for (let x = 90; x < 110; x++) {
                    if (x % 15 < 10) {
                        this.setTile(x, this.height - 55, 1);
                    }
                }
            }
            
            createDoubleJumpArea() {
                // Area requiring double jump (right side)
                const startX = 105;
                
                // Entry area - accessible with wall jump
                for (let x = startX - 5; x < startX + 2; x++) {
                    this.setTile(x, this.height - 40, 1);
                }
                
                // Medium height platform
                for (let x = startX + 5; x < startX + 12; x++) {
                    this.setTile(x, this.height - 35, 1);
                }
                
                // High platforms requiring double jump
                for (let x = startX + 8; x < startX + 15; x++) {
                    this.setTile(x, this.height - 50, 1);
                }
                
                // Very high platform - needs double jump (large gap)
                for (let x = startX + 22; x < startX + 28; x++) {
                    this.setTile(x, this.height - 52, 1);
                }
                
                // Final platform area with double jump item
                for (let x = startX + 25; x < startX + 32; x++) {
                    this.setTile(x, this.height - 58, 1);
                }
                
                // Victory platform at the top
                for (let x = startX + 35; x < startX + 42; x++) {
                    this.setTile(x, this.height - 65, 1);
                }
            }
            
            createVerticalShafts() {
                // Vertical movement areas with platforms
                
                // Left side shaft
                for (let y = this.height - 60; y < this.height - 10; y += 8) {
                    for (let x = 15; x < 18; x++) {
                        this.setTile(x, y, 1);
                    }
                }
                
                // Central shaft
                for (let y = this.height - 50; y < this.height - 15; y += 6) {
                    for (let x = 60; x < 63; x++) {
                        this.setTile(x, y, 1);
                    }
                }
                
                // Right side shaft
                for (let y = this.height - 70; y < this.height - 20; y += 10) {
                    for (let x = 125; x < 128; x++) {
                        this.setTile(x, y, 1);
                    }
                }
                
                // Emergency platforms throughout the world
                for (let x = 20; x < this.width - 20; x += 25) {
                    this.setTile(x, this.height - 35, 1);
                    this.setTile(x + 1, this.height - 35, 1);
                }
            }
            
            placeItems() {
                // Dash item - accessible after basic movement, requires big jump to platform
                this.items.push({
                    x: 61 * TILE_SIZE,
                    y: (this.height - 31) * TILE_SIZE,
                    type: 'dash',
                    collected: false,
                    sprite: sprites.dashItem
                });
                
                // Wall jump item - requires dash to reach, placed in wall jump area
                this.items.push({
                    x: 97 * TILE_SIZE,
                    y: (this.height - 49) * TILE_SIZE,
                    type: 'wallJump',
                    collected: false,
                    sprite: sprites.wallJumpItem
                });
                
                // Double jump item - requires wall jump to reach, at the highest platform
                this.items.push({
                    x: 128 * TILE_SIZE,
                    y: (this.height - 59) * TILE_SIZE,
                    type: 'doubleJump',
                    collected: false,
                    sprite: sprites.doubleJumpItem
                });
            }
            
            getTile(x, y) {
                if (x < 0 || x >= this.width || y < 0 || y >= this.height) {
                    return 1; // Solid boundary
                }
                return this.tiles[y * this.width + x];
            }
            
            setTile(x, y, value) {
                if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                    this.tiles[y * this.width + x] = value;
                }
            }
            
            render(ctx, camera) {
                const startX = Math.max(0, Math.floor(camera.x / TILE_SIZE));
                const endX = Math.min(this.width, Math.ceil((camera.x + 1200) / TILE_SIZE));
                const startY = Math.max(0, Math.floor(camera.y / TILE_SIZE));
                const endY = Math.min(this.height, Math.ceil((camera.y + 600) / TILE_SIZE));
                
                // Render tiles
                for (let x = startX; x < endX; x++) {
                    for (let y = startY; y < endY; y++) {
                        const tile = this.getTile(x, y);
                        if (tile === 1) {
                            ctx.fillStyle = '#3a3a5a';
                            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                            
                            ctx.strokeStyle = '#555';
                            ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        }
                    }
                }
                
                // Render items
                this.items.forEach(item => {
                    if (!item.collected) {
                        ctx.save();
                        
                        // Floating animation
                        const floatOffset = Math.sin(Date.now() / 500) * 5;
                        ctx.translate(item.x, item.y + floatOffset);
                        
                        // Glow effect
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#ffd700';
                        
                        // Create image from sprite data
                        const img = new Image();
                        img.onload = () => {
                            ctx.drawImage(img, 0, 0);
                        };
                        img.src = item.sprite;
                        
                        // Fallback rendering
                        ctx.fillStyle = '#ffd700';
                        ctx.beginPath();
                        ctx.arc(16, 16, 12, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                    }
                });
            }
            
            checkItemCollision(player) {
                this.items.forEach(item => {
                    if (!item.collected) {
                        const distance = Math.sqrt(
                            Math.pow(player.position.x - (item.x + 16), 2) +
                            Math.pow(player.position.y - (item.y + 16), 2)
                        );
                        
                        if (distance < 24) {
                            item.collected = true;
                            this.collectItem(item);
                        }
                    }
                });
            }
            
            collectItem(item) {
                switch (item.type) {
                    case 'dash':
                        gameState.abilities.dash = true;
                        this.showNotification('Dash ability unlocked! Press Shift to dash.');
                        break;
                    case 'wallJump':
                        gameState.abilities.wallJump = true;
                        this.showNotification('Wall Jump unlocked! Jump while sliding on walls.');
                        break;
                    case 'doubleJump':
                        gameState.abilities.doubleJump = true;
                        this.showNotification('Double Jump unlocked! Press jump again in mid-air.');
                        break;
                }
                
                // Update UI
                updateAbilityUI();
                
                // Particle effect
                // TODO: Add particle system integration
            }
            
            showNotification(message) {
                // Simple notification system
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.9);
                    color: #00f593;
                    padding: 20px;
                    border: 2px solid #00f593;
                    border-radius: 10px;
                    font-family: monospace;
                    font-size: 16px;
                    z-index: 1000;
                    max-width: 400px;
                    text-align: center;
                `;
                notification.textContent = message;
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 3000);
            }
        }

        // Game Scene
        class GameScene extends Scene {
            constructor(name, engine) {
                super(name, engine);
                this.world = new World();
                this.player = null;
            }

            init() {
                super.init();
                
                // Create player at spawn point - calculate proper Y position
                const spawnY = (this.world.height - 16) * TILE_SIZE; // Just above the ground
                this.player = new Player(200, spawnY);
                this.addGameObject(this.player);
                gameState.player = this.player;
                
                // Set initial camera position to follow player
                this.camera.x = Math.max(0, this.player.position.x - 600);
                this.camera.y = Math.max(0, this.player.position.y - 300);
            }

            update(deltaTime) {
                super.update(deltaTime);
                
                // Check item collections
                this.world.checkItemCollision(this.player);
                
                // Update UI
                updateHealthUI();
            }

            render(ctx) {
                // Clear background
                ctx.fillStyle = '#001122';
                ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                
                ctx.save();
                
                // Apply camera transform
                ctx.translate(-this.camera.x, -this.camera.y);
                
                // Render world
                this.world.render(ctx, this.camera);
                
                // Manually render player if it exists
                if (this.player && this.player.visible) {
                    ctx.save();
                    ctx.translate(this.player.position.x, this.player.position.y);
                    ctx.rotate(this.player.rotation);
                    ctx.scale(this.player.scale.x, this.player.scale.y);
                    ctx.globalAlpha = this.player.alpha;
                    
                    // Apply origin offset
                    const offsetX = -this.player.size.width * this.player.origin.x;
                    const offsetY = -this.player.size.height * this.player.origin.y;
                    ctx.translate(offsetX, offsetY);
                    
                    // Call player's draw method
                    this.player.draw(ctx);
                    ctx.restore();
                    
                    // Debug: Show player position
                    ctx.fillStyle = '#ffff00';
                    ctx.font = '12px monospace';
                    ctx.fillText(`P(${Math.round(this.player.position.x)},${Math.round(this.player.position.y)})`, 
                                this.player.position.x + 20, this.player.position.y - 20);
                }
                
                // Render other game objects via parent method
                super.render(ctx);
                
                // Debug: Draw camera bounds
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.camera.x, this.camera.y, 1200, 600);
                
                ctx.restore();
            }
        }

        // Mini-map rendering
        function renderMiniMap() {
            const canvas = document.getElementById('minimapCanvas');
            const ctx = canvas.getContext('2d');
            const world = gameScene?.world;
            
            if (!world || !gameState.player) return;
            
            // Clear mini-map
            ctx.fillStyle = '#000022';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Calculate scale
            const scaleX = canvas.width / (WORLD_WIDTH / TILE_SIZE);
            const scaleY = canvas.height / (WORLD_HEIGHT / TILE_SIZE);
            
            // Draw world tiles (simplified)
            ctx.fillStyle = '#444466';
            for (let x = 0; x < world.width; x += 4) { // Sample every 4th tile for performance
                for (let y = 0; y < world.height; y += 4) {
                    if (world.getTile(x, y) === 1) {
                        ctx.fillRect(x * scaleX, y * scaleY, scaleX * 4, scaleY * 4);
                    }
                }
            }
            
            // Draw items
            world.items.forEach(item => {
                if (!item.collected) {
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(
                        (item.x / TILE_SIZE) * scaleX,
                        (item.y / TILE_SIZE) * scaleY,
                        3, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
            });
            
            // Draw player
            ctx.fillStyle = '#ff206e';
            ctx.beginPath();
            ctx.arc(
                (gameState.player.position.x / TILE_SIZE) * scaleX,
                (gameState.player.position.y / TILE_SIZE) * scaleY,
                4, 0, Math.PI * 2
            );
            ctx.fill();
            
            // Draw visited areas overlay
            ctx.fillStyle = 'rgba(0, 245, 147, 0.2)';
            gameState.visitedAreas.forEach(area => {
                // Simple area highlighting - could be improved
                const areaX = area === 'start' ? 5 : area === 'dash' ? 35 : area === 'wallJump' ? 70 : 100;
                ctx.fillRect(areaX * scaleX, (world.height - 50) * scaleY, 30 * scaleX, 40 * scaleY);
            });
        }

        // UI Update functions
        function updateHealthUI() {
            const healthFill = document.getElementById('healthFill');
            const percentage = (gameState.health / gameState.maxHealth) * 100;
            healthFill.style.width = percentage + '%';
        }

        function updateAbilityUI() {
            const abilities = ['jumpAbility', 'dashAbility', 'wallJumpAbility', 'doubleJumpAbility'];
            const gameAbilities = ['jump', 'dash', 'wallJump', 'doubleJump'];
            
            abilities.forEach((abilityId, index) => {
                const element = document.getElementById(abilityId);
                const abilityName = gameAbilities[index];
                
                if (gameState.abilities[abilityName]) {
                    element.classList.add('unlocked');
                } else {
                    element.classList.remove('unlocked');
                }
            });
        }
        
        function updateCompletionUI() {
            const completion = saveSystem.calculateCompletion(gameState);
            const completionFill = document.getElementById('completionFill');
            const completionText = document.getElementById('completionText');
            
            completionFill.style.width = completion + '%';
            completionText.textContent = completion + '%';
        }
        
        function updateGameInfo() {
            // Update area name
            const areaName = document.getElementById('areaName');
            const currentArea = getCurrentAreaName();
            areaName.textContent = currentArea;
            
            // Update item count
            const itemCount = document.getElementById('itemCount');
            const collectedCount = Object.values(gameState.abilities).filter(Boolean).length - 1; // -1 for default jump
            itemCount.textContent = `Items: ${collectedCount}/3`;
            
            // Update play time
            const playTime = document.getElementById('playTime');
            const totalTime = gameState.playTime + (Date.now() - startTime) / 1000;
            const minutes = Math.floor(totalTime / 60);
            const seconds = Math.floor(totalTime % 60);
            playTime.textContent = `Time: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        function getCurrentAreaName() {
            if (!gameState.player || !gameState.player.position) return 'Starting Area';
            
            const x = gameState.player.position.x / TILE_SIZE;
            
            if (x < 30) return 'Starting Area';
            else if (x < 65) return 'Dash Chamber';
            else if (x < 95) return 'Wall Jump Ruins';
            else return 'Double Jump Peaks';
        }

        // Save/Load functions
        function quickSave() {
            gameState.playTime += (Date.now() - startTime) / 1000;
            startTime = Date.now();
            saveSystem.saveGame(gameState);
            lastAutoSave = Date.now();
        }
        
        function quickLoad() {
            const loadedData = saveSystem.loadGame();
            if (loadedData && loadedData.gameState) {
                // Apply loaded state
                Object.assign(gameState, loadedData.gameState);
                gameState.visitedAreas = new Set(loadedData.gameState.visitedAreas || ['start']);
                gameState.collectedItems = new Set(loadedData.gameState.collectedItems || []);
                
                // Update UI (but skip game info until player is created)
                updateAbilityUI();
                updateHealthUI();
                updateCompletionUI();
                // Don't call updateGameInfo() here - player doesn't exist yet
                
                // Reset play time tracking
                startTime = Date.now();
                
                console.log('Game loaded successfully');
            }
        }
        
        // Global reference to game scene for mini-map
        let gameScene = null;

        // Initialize Game
        async function initGame() {
            const engine = new GameEngine('gameCanvas', {
                fps: 60,
                responsive: false,
                pixelArt: true,
                audioEnabled: true,
                touchEnabled: true
            });

            // Wait for engine initialization
            await new Promise(resolve => {
                const checkEngine = () => {
                    if (engine.inputManager && engine.uiManager) {
                        resolve();
                    } else {
                        setTimeout(checkEngine, 100);
                    }
                };
                checkEngine();
            });

            // Create and start game scene first
            gameScene = new GameScene('game', engine);
            
            // Try to load existing save after player is created
            if (saveSystem.hasSaveData()) {
                const loadedData = saveSystem.loadGame();
                if (loadedData && loadedData.gameState) {
                    // Apply loaded state to existing player
                    Object.assign(gameState, loadedData.gameState);
                    gameState.visitedAreas = new Set(loadedData.gameState.visitedAreas || ['start']);
                    gameState.collectedItems = new Set(loadedData.gameState.collectedItems || []);
                    
                    // Update player position if we have save data
                    if (gameScene.player && loadedData.gameState.player) {
                        gameScene.player.position.x = loadedData.gameState.player.x;
                        gameScene.player.position.y = loadedData.gameState.player.y;
                        gameScene.player.health = loadedData.gameState.player.health;
                        // Update the gameState reference
                        gameState.player = gameScene.player;
                    }
                    
                    // Save data applied
                }
            }
            
            engine.addScene('game', gameScene);
            engine.switchScene('game');
            engine.start();

            // Setup input handlers
            setupInputHandlers(engine.inputManager);
            
            // Setup save controls
            setupSaveControls();
            
            // Start auto-save (every 2 minutes)
            saveSystem.startAutoSave(() => {
                gameState.playTime += (Date.now() - startTime) / 1000;
                startTime = Date.now();
                return gameState;
            }, 2);

            // Start UI update loop
            setInterval(() => {
                updateGameInfo();
                updateCompletionUI();
                renderMiniMap();
                
                // Auto-save every 5 minutes
                if (Date.now() - lastAutoSave > 300000) {
                    quickSave();
                }
            }, 1000);

            // Initialize UI
            updateAbilityUI();
            updateHealthUI();
            updateCompletionUI();
            updateGameInfo();

            // Hide loading screen
            document.getElementById('loading').style.display = 'none';

            // Ensure canvas has focus for input
            document.getElementById('gameCanvas').focus();
            document.getElementById('gameCanvas').setAttribute('tabindex', '0');
            
            // Add global keyboard listener as backup
            window.addEventListener('keydown', (e) => {
                if (e.code === 'Space' || e.key === ' ') {
                    if (gameState.player && gameState.player.grounded) {
                        gameState.player.velocity.y = JUMP_FORCE;
                    }
                    e.preventDefault();
                }
            });

            // Game initialized successfully
        }

        // Input handlers
        function setupInputHandlers(inputManager) {
            // Save system hotkeys
            window.addEventListener('keydown', (e) => {
                if (e.key === 'F5') {
                    e.preventDefault();
                    quickSave();
                } else if (e.key === 'F9') {
                    e.preventDefault();
                    toggleSaveMenu();
                } else if (e.key === 'm' || e.key === 'M') {
                    toggleMiniMap();
                }
            });
        }
        
        function setupSaveControls() {
            document.getElementById('saveBtn').addEventListener('click', quickSave);
            document.getElementById('loadBtn').addEventListener('click', () => {
                if (confirm('Load game? Any unsaved progress will be lost.')) {
                    quickLoad();
                    location.reload(); // Reload to reset game state properly
                }
            });
            
            document.getElementById('exportBtn').addEventListener('click', () => {
                saveSystem.exportSave();
            });
            
            document.getElementById('importBtn').addEventListener('click', () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.sav';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            const importData = event.target.result;
                            if (saveSystem.importSave(importData)) {
                                if (confirm('Save imported successfully! Reload the game to apply changes?')) {
                                    location.reload();
                                }
                            }
                        };
                        reader.readAsText(file);
                    }
                };
                input.click();
            });
        }
        
        function toggleSaveMenu() {
            const saveControls = document.getElementById('saveControls');
            saveControls.style.display = saveControls.style.display === 'none' ? 'block' : 'none';
        }
        
        function toggleMiniMap() {
            const minimap = document.getElementById('minimap');
            minimap.style.display = minimap.style.display === 'none' ? 'block' : 'none';
        }

        // Start the game when page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>